#!/bin/bash

# Check if the LFS variable is set
# If it isn't empty, it means that we are installing
# BirbOS and the LFS variable should be used as the
# installation prefix, so that all of the files end
# up into the correct directory
INSTALL_PREFIX="$LFS"

REPO_DIR="$INSTALL_PREFIX/var/db/pkg"
NEST="/var/lib/birb/nest"
export DISTFILES="$INSTALL_PREFIX/var/cache/distfiles"
export FAKEROOT="$INSTALL_PREFIX/var/db/fakeroot"

# Important packages that should prompt for confirmation when uninstalling
# to protect the system from becoming unusable
IMPORTANT_PACKAGES="
xz
file
gcc
"

print_help()
{
	echo "Usage: birb [OPTIONS...] [ARGUMENTS...] [PACKAGE(s)...]"
	echo ""
	echo "      --help                 display this help page and exit"
	echo "      --download PACKAGE(s)  download the source tarball for the given package"
	echo "      --uninstall PACKAGE(s) uninstall given package(s) from the filesystem"
	echo ""
	echo "If a valid package names are given as the only arguments, birb will attempt"
	echo "downloading and installing them"
}

if [ -z $1 ]
then
	print_help
	exit 0
fi

# Args: [file path] [checksum]
# Return values:
# 0 = Checksums match
# 1 = Checksums didn't match
checksum_check()
{
	FILE_PATH="$1"
	GOAL_CHECKSUM="$2"

	FILE_CHECKSUM="$(md5sum $DISTFILES/$TARBALL | cut -d' ' -f1)"

	# Make sure that either of the checksums aren't empty
	[ -z $GOAL_CHECKSUM ] && echo "1"
	[ -z $FILE_CHECKSUM ] && echo "1"

	[ "$GOAL_CHECKSUM" == "$FILE_CHECKSUM" ] && echo "0" || echo "1"
}

source_pkg_seed()
{
	source $REPO_DIR/$1/seed.sh
}

# Download a tarball for the given package using wget
# The tarball will be stored to /var/cache/distfiles
download_src()
{
	# Source the package variables
	source_pkg_seed $1

	# Get the tarball name from the download URL
	TARBALL="$(basename $SOURCE)"

	echo "=> Fetching $TARBALL..."

	# Check if the package tarball has already been downloaded
	# and the checksum matches
	if [ -f "$DISTFILES/$TARBALL" ]
	then
		echo "Found [$TARBALL] in distcache. Comparing checksums..."
		if [ "$(checksum_check "$DISTFILES/$TARBALL" "$CHECKSUM")" == "0" ]
		then
			# The tarball has already been downloaded and the download can
			# be skipped without any issues
			return 0
		fi
	fi

	# Download the source tarball
	wget --directory-prefix=$DISTFILES $SOURCE

	# Check the MD5 checksum
	if [ "$(checksum_check "$DISTFILES/$TARBALL" "$CHECKSUM")" == "1" ]
	then
		echo "WARNING! There was a checksum mismatch. The downloaded archive will be removed to prevent installing a possibly corrupt package. Please re-try downloading it"
		rm -v $DISTFILES/$TARBALL
		return 1
	fi
}

# Create some basic directories for the fakeroot
# in case the package isn't going to create those directories
# and gets confused
prepare_fakeroot()
{
	mkdir -p $1/{usr/{lib32,libx32},etc}
}

install_package()
{
	PACKAGE_NAME="$1"
	export PKG_PATH="$INSTALL_PREFIX/var/db/pkg/$PACKAGE_NAME"

	# Check if a package with this name is in the repositories
	if [ ! -d $PKG_PATH ]
	then
		echo "ERROR: There's no package with the name [$PACKAGE_NAME]"
		exit 1
	fi

	# Check if the package is already installed
	if [ -n "$(grep -x $PACKAGE_NAME $NEST)" ]
	then
		echo "$PACKAGE_NAME is already installed! Skipping..."
		return 1
	fi

	# Reset all package variables in-case some package has omitted
	# a variable or two
	NAME=""
	DESC=""
	VERSION=""
	SOURCE=""
	CHECKSUM=""
	DEPS=""
	FLAGS=""

	# Source the package variables and functions
	source_pkg_seed $PACKAGE_NAME

	# Check if the dependency requirements are met
	echo "=> Checking dependencies"
	HAD_MISSING_DEP=""
	for i in $DEPS
	do
		# Check if the dependency is installed
		if [ -z "$(grep -x $i $NEST)" ]
		then
			HAD_MISSING_DEP="yes"
			echo "[ ] $i"
			continue
		else
			echo "[âœ“] $i"
		fi
	done

	if [ "$HAD_MISSING_DEP" == "yes" ]
	then
		echo "Missing dependencies were found. Would you like to attempt installing them?"
		read -p "[Y/n]: " AGREE_INSTALL_DEPS
		case $AGREE_INSTALL_DEPS in
			n|N|n*|N*)
				echo "Cancelled"
				exit 1
				;;

			""|y|Y|y*|Y*) ;;

			*)
				echo "Cancelled"
				exit 1
				;;
		esac

		echo "=> Attempting to install the following packages: [$DEPS]"
		birb $DEPS || { echo "Something went wrong while trying to install dependencies. Cancelling the mission..."; exit 1; }
	fi

	# Attempt to download the package
	download_src $PACKAGE_NAME
	[ $? -eq 1 ] && echo "Error during downloading [$PACKAGE_NAME]. Aborting the mission..." && exit 1


	# Make sure that the package has set all of the required variables
	[ -z "$NAME" ] 		&& echo "Encountered a package with a missing name! Aborting the mission..." && exit 1
	[ -z "$SOURCE" ] 	&& echo "Encountered a package without a tarball source! Aborting the mission..." && exit 1
	[ -z "$CHECKSUM" ] 	&& echo "Encountered a package without a checksum! Aborting the mission..." && exit 1

	# Check if the package wants to also build 32bit libraries
	ENABLE_32BIT="$(echo "$FLAGS" | grep -o "32bit")"

	set -e

	# Extract the package sources and do any required setup
	TEMPORARY_BUILD_DIR="/tmp/birb_package_build"
	rm -rf $TEMPORARY_BUILD_DIR
	mkdir -p $TEMPORARY_BUILD_DIR
	cd $TEMPORARY_BUILD_DIR
	echo "=> Setting things up for compiling"
	_setup

	# Build the package
	echo "=> Building the package"
	_build

	# Install the package into fakeroot directory
	echo "=> Installing the package"
	prepare_fakeroot $FAKEROOT/$PACKAGE_NAME
	_install

	if [ -n "$ENABLE_32BIT" ]
	then
		echo "=> Building the package with 32-bit libraries"
		_build32

		echo "=> Installing 32-bit libraries"
		_install32

		echo "=> Building the package with x32-bit libraries"
		_buildx32

		echo "=> Installing x32-bit libraries"
		_installx32
	fi

	# Clean things up
	echo "=> Cleaning up"
	rm -r $TEMPORARY_BUILD_DIR

	# Find all files in the fakeroot and delete them from the system root
	#echo "=> Removing any existing files"
	#FILES_TO_REMOVE="$(find $FAKEROOT/$PACKAGE_NAME -type f | sed "s|$FAKEROOT/$PACKAGE_NAME||")"
	#rm -rvf $FILES_TO_REMOVE

	# Stow the fakeroot directory to the root directory
	echo "=> Finding and deleting conflicting files"
	cd $FAKEROOT
	set +e
	FILES_TO_DELETE="$(stow -S -t / -d $FAKEROOT $PACKAGE_NAME &>/dev/stdout | grep "existing target is not owned by stow" | awk -F' ' '{print "/" $9}')"
	set -e
	rm -f $FILES_TO_DELETE

	# Do another round of deletions in case there's some other error
	set +e
	FILES_TO_DELETE="$(stow -S -t / -d $FAKEROOT $PACKAGE_NAME &>/dev/stdout | grep "existing target is neither a link nor a directory" | awk -F' ' '{print "/" $11}')"
	set -e
	rm -f $FILES_TO_DELETE


	echo "=> Symlinking the package fakeroot to the system root"
	stow -S -t / -d $FAKEROOT $PACKAGE_NAME

	# Add the package into the nest file if the installation was successful
	echo "$PACKAGE_NAME" >> $NEST

	echo "$PACKAGE_NAME installation finished"
	set +e
}

uninstall_package()
{
	PACKAGE_NAME="$1"
	echo "=> Checking if the package $PACKAGE_NAME is in the nest"
	if [ -z "$(grep -x $PACKAGE_NAME $NEST)" ]
	then
		echo "$PACKAGE_NAME is not installed"
		return 1
	fi

	# Protect the user from destroying their installation
	IS_PROTECTED="$(echo "$IMPORTANT_PACKAGES" | grep -x "$PACKAGE_NAME")"
	if [ -n "$IS_PROTECTED" ]
	then
		echo "!! WARNING !!"
		echo "Removing this package might cause some serious harm to your system"
		echo "and render it partially unusable."
		echo ""
		echo "Please make sure you have a way to restore this package afterwards"
		echo "without the use of a package manager (and possibly other tools"
		echo "that aren't available)"
		echo ""
		read -p "Continue? [y/N]: " UNINSTALL_PROTECTED_PACKAGE

		case $UNINSTALL_PROTECTED_PACKAGE in
			y|Y|yes|Yes)
				echo "I hope you know what you are doing..."
				;;

			*)
				echo "Cancelled"
				return 1;
				;;
		esac
	fi

	set -e
	echo "=> Unlinking $PACKAGE_NAME..."
	stow -D -t / -d $FAKEROOT $PACKAGE_NAME

	echo "=> Removing fakeroot"
	rm -r $FAKEROOT/$PACKAGE_NAME

	sed -i "/$PACKAGE_NAME/d" $NEST
	echo "$PACKAGE_NAME uninstalled"
	set +e
}

# Check if the first argument is a valid package name
if [ -d "$REPO_DIR/$1" ]
then
	# Process the arguments as package names and install
	# all of them
	while test $# -gt 0; do
		install_package "$1"
		shift
	done
fi

# Go through all of the arguments
while test $# -gt 0; do
	case $1 in
		--help)
			shift
			print_help
			exit 0
			;;

		--download)
			shift

			while test $# -gt 0; do
				download_src $1
				shift
			done

			exit 0
			;;

		--uninstall)
			shift

			while test $# -gt 0; do
				uninstall_package $1
				shift
			done

			exit 0
			;;

		*)
			echo "Package $1 does not exist"
			exit 1
		;;
	esac
done
